/**
 * @(#)JMainFrame.java
 *
 * JReversePro - Java Decompiler / Disassembler.
 * Copyright (C) 2000 2001 Karthik Kumar.
 * EMail: akkumar@users.sourceforge.net
 *
 * This program is free software; you can redistribute it and/or modify
 * it , under the terms of the GNU General Public License as published
 * by the Free Software Foundation; either version 2 of the License,
 * or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program.If not, write to
 *  The Free Software Foundation, Inc.,
 *  59 Temple Place - Suite 330,
 *  Boston, MA 02111-1307, USA.
 **/
package jreversepro;

import jreversepro.common.AppConstants;
import jreversepro.common.Helper;
import jreversepro.common.KeyWords;
import jreversepro.gui.*;
import jreversepro.parser.ClassParserException;
import jreversepro.reflect.JClassInfo;
import jreversepro.reflect.JField;
import jreversepro.reflect.JImport;
import jreversepro.reflect.JMethod;
import jreversepro.revengine.JSerializer;
import jreversepro.revengine.RevEngineException;

import javax.swing.*;
import javax.swing.plaf.metal.MetalLookAndFeel;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

//Custom Packages

/**
 * Entry point for swing-based GUI
 *
 * @author Karthik Kumar
 */
public class JMainFrame
        extends JFrame
        implements ActionListener, KeyWords,
        WindowListener, AppConstants {

    /**
     * Represents the MenuBar.
     */
    private MainMenu mMbrGen;

    /**
     * Panel containing the Reverse engineered code.
     */
    private JClassEditPanel mPnlEditor;

    /**
     * Panel containing the status bar.
     */
    private JStatusPanel mPnlStatusBar;

    /**
     * ConstantPool Information of the class.
     */
    private JSerializer mSerializer;

    /**
     * Path to class currently reverse engineered.
     */
    private String mCurrentClass;

    /**
     * JClassInfo class currently reverse engineered.
     */
    private JClassInfo mClassInfo;

    /**
     * Name of the property file.
     */
    private String mPropertyFile;

    /**
     * Default Directory of a file open/save dialog.
     */
    private String mCurDir;


    /**
     * No-argument constructor.
     */
    public JMainFrame() {
        super(TITLE);

        mPropertyFile = System.getProperty("user.home")
                + System.getProperty("file.separator")
                + PROP_FILE;

        mPnlEditor = new JClassEditPanel();
        mPnlStatusBar = new JStatusPanel();
        mSerializer = new JSerializer();

        mPnlEditor.setPreferredSize(new Dimension(500, 200));
        mPnlStatusBar.setPreferredSize(new Dimension(500, 20));

        getContentPane().setLayout(new BorderLayout());
        getContentPane().add(mPnlEditor, BorderLayout.CENTER);
        getContentPane().add(mPnlStatusBar, BorderLayout.SOUTH);

        mMbrGen = new MainMenu(this);
        setJMenuBar(mMbrGen);

        mCurDir = ".";

        mMbrGen.OnViewCPool.setEnabled(false);

        initAppState();
        addListeners();
    }

    /**
     * Driver method for GUI application.
     *
     * @param aArgs This argument is insignificant.
     */
    public static void main(String aArgs[]) {
        if (Helper.versionCheck()) {
            (new JMainFrame()).setVisible(true);
        }
    }

    /**
     * Method containing handlers for events generated by
     * MenuItems.
     *
     * @param aEvent Event generated by GUI.
     */
    public void actionPerformed(ActionEvent aEvent) {
        if (aEvent.getSource() == mMbrGen.OnFileOpen) {
            openFile();
        } else if (aEvent.getSource() == mMbrGen.OnFileSave) {
            saveFile();
        } else if (aEvent.getSource() == mMbrGen.OnFileExit) {
            appClose();
        } else if (aEvent.getSource() == mMbrGen.OnViewCPool) {
            viewPool();
        } else if (aEvent.getSource() == mMbrGen.OnOptFont) {
            showFontDialog();
        } else if (aEvent.getSource() == mMbrGen.OnHelpAbout) {
            showAbout();
        } else if (aEvent.getSource() == mMbrGen.OnEditCut) {
            cutText();
        } else if (aEvent.getSource() == mMbrGen.OnEditCopy) {
            copyText();
        }
    }

    /**
     * Method to open a file.
     */
    public synchronized void openFile() {
        JCustomFileChooser chooser =
                new JCustomFileChooser(mCurDir,
                        "Class Files", ".class", "Open File");
        if (chooser.showChooser(this, "Decompile File")
                == JFileChooser.APPROVE_OPTION) {
            File f = chooser.getSelectedFile();
            mCurDir = f.getAbsolutePath();
            try {
                reverseEngineer(f);
            } catch (Exception _ex) {
                (new JErrorDlg(this, f.toString(), _ex)).setVisible(true);
            }
        }
    }

    /**
     * Method to reverse engineer a file.
     *
     * @param aFile Class file to be reverse engineered.
     * @throws ClassParserException Thrown if class file not in proper format.
     * @throws IOException          Thrown if error occured in reading class file.
     * @throws RevEngineException   Thrown if error occured in reverse
     *                              engineering file.
     */
    private synchronized void reverseEngineer(File aFile)
            throws ClassParserException,
            IOException,
            RevEngineException {
        mClassInfo = mSerializer.loadClass(aFile);
        String code = null;
        mClassInfo.reverseEngineer(true);
        code = mClassInfo.getStringifiedClass(
                mMbrGen.OnDecompiler.isSelected());

        mPnlEditor.writeCode(code);
        mMbrGen.OnViewCPool.setEnabled(true);
//      createTree(mClassParser.getClassInfo() , mCurrentClass);
    }

    /**
     * Method invoked while saving to a file.
     */
    public void saveFile() {
        JCustomFileChooser chooser =
                new JCustomFileChooser(mCurDir, "Java Source Files",
                        ".java", "Save File");
        if (chooser.showChooser(this, "Save File")
                == JFileChooser.APPROVE_OPTION) {
            mPnlEditor.writeToFile(this, chooser.getSelectedFile());
        }
    }

    /**
     * Method invoked while closing a file.
     */
    public void appClose() {
        if (ConfirmCloseDialog.confirmExit(this)) {
            saveProperties();
            System.exit(0);
        }
    }

    /**
     * Method invoked while text is cut.
     */
    public void cutText() {
        //  System.out.println("Text Cut");
    }

    /**
     * Method invoked while text is copied.
     */
    public void copyText() {
        //  System.out.println("Text Copied");
    }

    /**
     * Method invoked while ConstantPool is viewed.
     */
    public void viewPool() {
        JCpDialog dlgPool = new JCpDialog(this,
                mCurrentClass, mClassInfo.getConstantPool());
        dlgPool.setVisible(true);
        dlgPool = null;
    }


    /**
     * Method invoked while System Font is being viewed.
     */
    public void showFontDialog() {
        JDlgFont dlg = new JDlgFont(this, "System Fonts");
        if (dlg.showFontDialog() == JDlgFont.SELECTED) {
            mPnlEditor.setEditorFont(dlg.getChosenFont());
        }
    }

    /**
     * Method invoked to show the About dialog box.
     */
    public void showAbout() {
        JDlgAbout about = new JDlgAbout(this, "About");
    }

    /**
     * Method invoked to initialize the GUI parameters.
     */
    private void initAppState() {
        //Set Default Theme.
        MetalLookAndFeel.setCurrentTheme(new MyFavTheme());
        setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
        try {
            Properties pp = new Properties();
            FileInputStream fis = new FileInputStream(mPropertyFile);
            pp.load(fis);
            fis.close();
            int x = Integer.parseInt(pp.getProperty(XPOS));
            int y = Integer.parseInt(pp.getProperty(YPOS));
            int width = Integer.parseInt(pp.getProperty(XSIZE));
            int height = Integer.parseInt(pp.getProperty(YSIZE));
            mMbrGen.OnLookFeel.setAppLookAndFeel(
                    pp.getProperty(L_AND_F));

            mMbrGen.setFlag(pp.getProperty(DECOMPILE_FLAG));
            mPnlEditor.setEditorFont(
                    new Font(pp.getProperty(FONT),
                            Font.PLAIN,
                            JDlgFont.OPTIMUM_SIZE));

            setLocation(x, y);
            setSize(width, height);
        } catch (FileNotFoundException fnfe) {
            setLocation(0, 0);
            setSize(800, 550);
            mPnlEditor.setEditorFont(
                    new Font(mPnlEditor.DEFAULT_FONT,
                            Font.PLAIN,
                            JDlgFont.OPTIMUM_SIZE));
            mMbrGen.OnLookFeel.setDefaultLookAndFeel();
            System.err.println("Failed to load property file");
        } catch (IOException ioe) {
            System.err.println("Exception while closing a property file ");
        }
    }


    /**
     * Method to add property listeners to MenuItems and the MainFrame.
     */
    private void addListeners() {
        mMbrGen.OnFileOpen.addActionListener(this);
        mMbrGen.OnFileSave.addActionListener(this);
        mMbrGen.OnFileExit.addActionListener(this);

        mMbrGen.OnEditCut.addActionListener(this);
        mMbrGen.OnEditCopy.addActionListener(this);
        mMbrGen.OnViewCPool.addActionListener(this);
        mMbrGen.OnOptFont.addActionListener(this);

        mMbrGen.OnHelpAbout.addActionListener(this);
        addWindowListener(this);
    }

    /**
     * Formats the title from the string Rhs and sets the title of the Frame.
     *
     * @param aFileName Full Path name to the class being reverse engineered.
     */
    private void formatTitle(String aFileName) {
        int dotIndex = aFileName.indexOf(".");
        if (dotIndex != -1) {
            String className = aFileName.substring(0, dotIndex);
            setTitle(TITLE + " - " + className);
        }
    }


    /**
     * Save the state of the GUI as a properties file.
     */
    private void saveProperties() {
        try {
            Properties pp = new Properties();
            pp.setProperty(DECOMPILE_FLAG,
                    new Boolean(mMbrGen.OnDecompiler.isSelected()).toString());
            pp.setProperty(XPOS,
                    new Integer(getLocation().x).toString());
            pp.setProperty(YPOS,
                    new Integer(getLocation().y).toString());
            pp.setProperty(XSIZE,
                    new Integer(getSize().width).toString());
            pp.setProperty(YSIZE,
                    new Integer(getSize().height).toString());
            pp.setProperty(L_AND_F,
                    mMbrGen.OnLookFeel.getAppLookAndFeel());
            pp.setProperty(FONT,
                    mPnlEditor.getEditorFont().getFamily());

            FileOutputStream fos = new FileOutputStream(mPropertyFile);
            pp.store(fos, PROP_HEADING);
            fos.close();
        } catch (Exception _ex) {
            System.err.println("Failed to write Properties" + mPropertyFile);
            System.err.println(_ex);
        }
    }


    /**
     * WindowClosing event handler.
     *
     * @param aEvent Event generated.
     */
    public void windowClosing(WindowEvent aEvent) {
        appClose();
    }

    /**
     * WindowClosing event handler.
     *
     * @param aEvent Event generated.
     */
    public void windowClosed(WindowEvent aEvent) {
    }

    /**
     * WindowClosing event handler.
     *
     * @param aEvent Event generated.
     */
    public void windowActivated(WindowEvent aEvent) {
    }

    /**
     * WindowClosing event handler.
     *
     * @param aEvent Event generated.
     */
    public void windowDeactivated(WindowEvent aEvent) {
    }

    /**
     * WindowClosing event handler.
     *
     * @param aEvent Event generated.
     */
    public void windowIconified(WindowEvent aEvent) {
    }

    /**
     * WindowClosing event handler.
     *
     * @param aEvent Event generated.
     */
    public void windowDeiconified(WindowEvent aEvent) {
    }

    /**
     * WindowClosing event handler.
     *
     * @param aEvent Event generated.
     */
    public void windowOpened(WindowEvent aEvent) {
    }

    /**
     * Creates the JTree of the LHS Panel ssociated with the class.
     *
     * @param aClassInfo    Informartion about the class.
     * @param aCurrentClass Name of the current class being reverse
     *                      engineered.
     */
    private void createTree(JClassInfo aClassInfo, String aCurrentClass) {
        JImport mImports = aClassInfo.getConstantPool().getImportedClasses();
        int dotIndex = aCurrentClass.indexOf(".");
        if (dotIndex != -1) {
            aCurrentClass = aCurrentClass.substring(0, dotIndex);
        }

        List listFields = aClassInfo.getFields();
        List listMethods = aClassInfo.getMethods();
        int i = 0;
        List result = new ArrayList();

        for (i = 0; i < listFields.size(); i++) {
            StringBuffer sb = new StringBuffer("");
            JField field = (JField) listFields.get(i);
            String datatype =
                    mImports.getClassName(
                            Helper.getJavaDataType(field.getDatatype(), false));

            sb.append(field.getQualifier());
            sb.append(" " + datatype);
            sb.append(" " + field.getName());
            result.add(sb.toString());
        }

        for (i = 0; i < listMethods.size(); i++) {
            JMethod method = (JMethod) listMethods.get(i);
            StringBuffer sb = new StringBuffer("");

            String returnType =
                    mImports.getClassName(
                            Helper.getJavaDataType(
                                    method.getReturnType(), false));

            String name = method.getName();


            if (name.compareTo(CLINIT) == 0) {
                sb.append(STATIC);
            } else if (name.compareTo(INIT) == 0) {
                sb.append(method.getQualifier());
                sb.append(aCurrentClass);
                sb.append(writeArgs(method.getArgList(), mImports));
            } else {
                sb.append(method.getQualifier());
                sb.append(returnType);
                sb.append(" " + name);
                sb.append(writeArgs(method.getArgList(), mImports));
            }
            result.add(sb.toString());
        }
        mPnlEditor.createModel(this, aCurrentClass, result);
    }

    /**
     * Returns the argument in Java language Class Format.
     *
     * @param aArgs    List of arguments of class names in JVM class format.
     * @param aImports List of imported classes.
     * @return A Concatenated list of classes separated by a comma.
     */
    private StringBuffer writeArgs(List aArgs, JImport aImports) {
        StringBuffer result = new StringBuffer("(");
        for (int i = 0; i < aArgs.size(); i++) {
            if (i != 0) {
                result.append(" ,");
            }
            String argType = aImports.getClassName(
                    Helper.getJavaDataType(
                            (String) aArgs.get(i), false));
            result.append(argType);
        }
        result.append(")");
        return result;
    }
}
